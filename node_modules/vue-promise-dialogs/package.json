{
  "name": "vue-promise-dialogs",
  "version": "2.0.0",
  "author": "Kirill Romanov",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/Djaler/vue-promise-dialogs"
  },
  "keywords": [
    "vue",
    "promise",
    "dialogs",
    "async"
  ],
  "files": [
    "dist"
  ],
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/types/index.d.ts",
  "sideEffects": false,
  "dependencies": {
    "vue-demi": "^0.13.4"
  },
  "peerDependencies": {
    "@vue/composition-api": "^1.1.0",
    "vue": "^2.6.4 || ^3.2.0"
  },
  "peerDependenciesMeta": {
    "@vue/composition-api": {
      "optional": true
    }
  },
  "readme": "[![npm](https://img.shields.io/npm/v/vue-promise-dialogs?style=for-the-badge)](https://www.npmjs.com/package/vue-promise-dialogs)\n[![npm bundle size](https://img.shields.io/bundlephobia/minzip/vue-promise-dialogs?style=for-the-badge)](https://bundlephobia.com/result?p=vue-promise-dialogs)\n[![demo](https://img.shields.io/badge/demo-green?style=for-the-badge)](https://djaler.github.io/vue-promise-dialogs/#/)\n\n# Vue Promise Dialogs\n\n> A tiny & modern library that allows you to work with dialogs as with asynchronous functions.\n\n## Why?\n\nBecause many dialogs work exactly as promises. \nThey are opened (called) and then closed with some result (resolved) or canceled (rejected).\n\n## Install\n\n> From version 2.0.0 it works for Vue 2 and Vue 3 within a single package by the power of [vue-demi](https://github.com/vueuse/vue-demi) ðŸ”¥\n\n### Vue 3\n\n```sh\nnpm install vue-promise-dialogs\n```\n\n### Vue 2\n\n```sh\nnpm install vue-promise-dialogs @vue/composition-api\n```\n\n## Usage\n\nMain requirements:\n\n1. You should mount exactly one `PromiseDialogsWrapper` somewhere in your application root.\n2. The dialog component should accept `params` props.\n3. The dialog component should emit `resolve` or `reject` events when the user makes a decision.\n\n```ts\nimport { createPromiseDialog } from \"vue-promise-dialogs\"\n\ninterface BooleanDialogParams {\n    text: string;\n}\n\nconst BooleanDialog = defineComponent({\n    template: `\n      <div class=\"dialog\">\n          <p>{{ params.text }}</p>\n          <button name=\"true\" @click=\"$emit('resolve', true)\">True</button>\n          <button name=\"false\" @click=\"$emit('resolve', false)\">False</button>\n          <button name=\"cancel\" @click=\"$emit('reject', 'cancel')\">Cancel</button>\n      </div>\n    `,\n    props: {\n        params: {\n            type: Object as PropType<BooleanDialogParams>,\n            required: true,\n        },\n    },\n});\n\n// First type argument is the type of params prop that will be passed to component\n// Second type argument is the type of value with which the promise will be fulfilled\nconst openDialog = createPromiseDialog<BooleanDialogParams, boolean>(BooleanDialog);\n\n// When you call this function, dialog will be mounted to `PromiseDialogsWrapper`.\n// When user press any button and resolve/reject event emitted, promise will be settled and dialog will be destroyed.\nconst result: boolean = await openDialog({ text: 'Some text' });\n```\n\n### Unmount delay\n\nBy default, a dialog is unmounted immediately right after resolve/reject, but maybe you want to change this behaviour, for example, to play the close animation. \n\nYou have two options here:\n\n1. Specify the unmount delay (in ms) using `unmountDelay` prop in `PromiseDialogsWrapper`.\n2. Specify the unmount delay (in ms) as a second argument when emitting `resolve`/`reject` event. This option will override `unmountDelay` prop if both are provided.\n\n### Close all\n\nIn some cases you may want to close all opened dialogs. For example, on route change.\n\nYou can use `closeAllDialogs` for this. All you need is to set a reason, which will be used in promises reject.\n\n## TODO\n- [ ] Fallback to mount dialogs without PromiseDialogsWrapper\n"
}